<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>cellsociety_team13: /tmp/git/duke-compsci308-spring2015/cellsociety_team13/repository/DESIGN.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cellsociety_team13
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/tmp/git/duke-compsci308-spring2015/cellsociety_team13/repository/DESIGN.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d1/d97/_d_e_s_i_g_n_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;CellSociety Design Document</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;===================</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Callie Mao, Kevin Delgado, Le Qi</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Introduction</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;-------------</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;The primary goals of the project are to allow a user to input rules and parameters regarding a CA simulation, present the user with a graphical representation of the simulation as it runs, and give the user the ability to start, pause, step-through, and adjust the rate of the simulation. At a high level, the program will parse a user defined XML file containing the rules underlying the simulation, the parameters required by these rules, and the initial conditions. </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;The overarching design of the program focuses on two categories of classes: views and controllers. The views use the data contained in the XML file to implement the visual displays and UI elements for user interaction while the controllers specify the algorithms for updating these views through each iteration as well as controlling how the user’s interaction with the UI elements (eg start and pause buttons) affect the progression of the simulation. </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;The program is designed to be most flexible where the simulation is actually controlled. In essence, the program should be able to handle any number of simulations due to the openness of the simulation controller for extension in order to handle a wide variety of logic cases. The simulation controller should be closed to modification in the sense that all simulations work via the same overarching rules (ie, checking the state of each cell, checking the state of neighboring cells, and updating the state of each cell based on the state of neighboring cells). The views of the program should not be flexible, because keeping each cell limited to only containing information relevant it current state should sufficiently handle any simulation so long as the controllers are robust and flexible.</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;----</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;Overview</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;-------------</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;The following chart depicts the relationship between our classes:</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;![Design Overview](http://i.imgur.com/B5Hy8xJ.jpg)</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;The following components will be used to build our program:</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;* **Main**</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;Calls CellSociety to start the program.</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;* **CellSociety**</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;The CellSociety class will be the main class that holds the elements of the game, which would include instances of the UI Elements, the Game Manager class, the SimController class, and the Grid.</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;* **Grid**</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   The Grid will be a JavaFX GridPane whose size is determined by the XML file (as parsed by the GameManager). It will have public methods to manipulate the cells inside it via the GameManager</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;* **Cell**</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;   The Cell will be closed to the grid but the grid will be able to access and update the cell’s state depending on the results dictated by the controller classes. The cell class itself will be designed for all visual elements of the cell as well as the cell’s state. The cell object extends the JavaFX rectangle class and holds the state of the cell as a CellState object and the color of the cell as a Color object. It should have methods that are able to return the state of the cell, as well as methods that can set the state for manipulation by other functions.  </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;* **CellState** </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;   The CellState object will be the minimum. The CellState superclass will have fields myColor (the color of the cell in the Grid) and myLabel (a String that is the minimum a state of a cell in CA can be, such as “fire”, “shark”, or “live”). It will implement getColor() and getLabel. Some game rules require the state of a cell to hold more than just its label though, such as amount of energy or time until reproduction. The states are subclasses of CellState, they are listed below and are gone over in the design details section.</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;   * SharkState</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;   * FishState</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;* **UI elements**</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;   The UIElements will provide features that allow the user to start, pause, step through, stop, set frame rate, and upload a new XML file. The UIElements will interact with the GridView class to update the game. </div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;   * Speed (slider or text input)</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;   * Upload New XML</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;   * Button (from JavaFX)</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;       * Start</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;       * Pause</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;       * Step</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;* **XMLParser**</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;   XML parser will take in a filepath to an XML file to parse it in order to set the initial state of the cells on the grid as well as well as provide parameters for the controller classes’ algorithms. It will call constructors in the appropriate controllers and set parameters/values based on numbers/values passed in from the XML formatting. </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;* **GameManager**</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    GameManager sets up the grid, calls the XMLParser class to parse the XML file, and updates the grid. In updating the grid, it will call SimController to access algorithms from the controller to update cells to their new states. When the play button is pressed it calls SimController.update() at the rate specified by the user. When the pause button is pressed it ceases calling SimController.update(). Each time the step button is pressed, SimController.update() is called a single time. When the UploadXML button is pressed, the GameManager ceases calling SimController.update() (if the simulation is playing) allows the user to input a new XML file. It calls the XML parsing object to determine the class fields of the GameManager. The fields of GameManager include, the SimController (ie. which specific implementation of it).</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;* **SimController**</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;The SimController abstract class handles the underlying logic of the simulation. It takes in the grid object and simulation parameters object as arguments to its constructor. It has an update() method that instantiates a new grid and loops through every cell in the grid and for each cell and does the following:</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;   * gets the state of the cell (cellState) by calling the method Cell.getState();</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;   * gets a list of adjacent cells by implementing and calling  List&lt;Cell&gt; hood = getHood(Cell, Grid)</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;   * gets the state of the cell’s neighborhood (hoodState) by calling the abstract method getHoodState(hood)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;   * defines the updated state of the cell by calling the abstract method newState(cellState, hoodState) and sets the corresponding cell in the newly instantiated grid to be</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;The last thing the update() method does after iterating through each cell on the grid is to call method updateGrid() such that the Grid in the scene is replaced by the new Grid with updated cells.</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;   At a high level each of the four controllers below extend SimController and implement it’s abstract methods getHood(Cell, Grid) and newState(cellState, hoodState). How these abstract methods are implemented are gone over in detail in the Design Details section below</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;   * Fire Controller</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;   * Wa-Tor Controller</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;   * Segregation Controller</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;   * Life Controller</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;----</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;User Interface</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;----</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;In the scene, the user will be able to see the grid in place with all of the specific cells in any given state. The user will also be able to see multiple buttons that it can click in order to change the state of the simulation, including reset, start, pause/play in order to effectively manipulate the state of the program. An example can be seen in the picture below.</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;![UI Design](http://i.imgur.com/ifO0B9R.jpg?1)</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;When the start button is clicked, the simulation should start and automatically update its cells based on those cell values. When the play/pause button is clicked, the simulation should immediately stop in whichever state it is currently in. The view and state of the cells should no longer change. When the play/pause button is pressed again, the cell states should continue to update, and the scene should then change accordingly as well. Pressing the reset button at anytime should then reinitialize the state of the program, and restore all of the cells to its corresponding states, which should update the view as well to reflect that.</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;A speed textbox will allow the user to select how many frames per second to play the animation at. If the user enters a negative value, an error message should appear at the bottom, specifying the problem and asking the user to fix it. If a number above 200 is entered, a similar error message is reported. An alternative to this could be a speed slider that limits the numbers that the user </div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;If the initial XML file does not follow the format that we specify, a message should be displayed to the user saying that the format was wrong as well.At this point, the simulations should not run and the program should not be active because no information can be represented.</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;---</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;Design Details </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;----</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;A broader overview of the classes outlined in the Overview is given below.</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;* **CellSociety** The CellSociety class functions as the view of the entire simulation. </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;* **Grid** (Fully detailed in Overview)</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;* **Cell** (Fully detailed in Overview)</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;* **CellState**</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;   * **FishState** Has field reproductionTime</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;       * **SharkState** Extends FishState, has field energy</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;* **UI elements**</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;   * **Speed** (slider or text input) - a text input will exist to allow the user to select the frames/second to play the animation/simulation at. Doing so will access the CellSociety class and update the frames per second that the animation will play at. </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;   * **Upload new XML** - selecting this option pulls up a screen that allows the user to select a different XML file. Doing so will stop the current game, reinitialize it with the new parameters, and play the game once again</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;   * **Button**</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;       * Start - Start the animation and allow the CA to progress </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;       * Pause - Stop by the CA but maintain all current features/states</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;       * Step - This button will allow the user to progress through the CA frame by frame. Each click will advance the animation by one frame. </div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;* **XMLParser**</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;The XML Parser will read in elements from the XML file and set constructors to the controllers with the specified parameters. The XML file will be passed in in a format similar to the below with specific rules to be implemented later on:</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;```xml</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;&lt;init&gt;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;   &lt;simName&gt;Fire&lt;/simName&gt;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;   &lt;author&gt;author&lt;/author&gt;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;   &lt;xDim&gt;xDimensions&lt;/xDim&gt;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;   &lt;yDim&gt;yDim&lt;/yDim&gt;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;&lt;/init&gt;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;&lt;state&gt;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;   &lt;num&gt;numStates&lt;/num&gt;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;   &lt;state type = “tree”&gt;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;       &lt;color&gt;0x000ff&lt;/color&gt;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;       &lt;rules&gt;rules organized here based on format appropriate with code&lt;/rules&gt;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;   &lt;state type = “ash”&gt;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;       &lt;color&gt;0x00000&lt;/color&gt;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;       &lt;rules&gt;&lt;/rules&gt;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;   &lt;state type = “fire”&gt;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;       &lt;color&gt;0x000ee&lt;/color&gt;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;       &lt;rules&gt;rules organized here based on format appropriate with code</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;&lt;/rules&gt;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;&lt;/state&gt;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;```</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;The XMLParser will parse through the file and call constructors/methods from cell and the controller classes to set rules and values (ie. method calls similar to createNewCell(parsedColor, parsedState)) or new FireController(parsedRatio1, parsedTreeProbability, parsedFireProbability), etc.). This class is included in the game design in order to allow for specfic updating interactions involved with the initial setup of the simulation scene and simulation rules. It will contain the following methods:</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;   * set</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;   * setCell</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;* **GameManager**</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;GameManager will contain the following methods:</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   * init(File file){</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;   //this method will initialize the game scene by </div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;   calling createControllers();</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;   calling createGrid();</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;};</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;   * createControllers(){</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;   //this method will interact with the XMLParser class to parse the XML file and set the properties to the revelvant controller</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;}  </div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;   * createGrid(){</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;   //this method will create the grid by interacting with the Grid class which holds all specfications for the grid’s attributes and properties</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;};</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;   * updateGrid(){</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;   //this method will use setter methods in the Grid class to reset its state based on the results of running the current algorithms. It will need to have access to the SimController and/or the specific controller subclass in order to determine what changes need to be made. </div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;   * private void pause(){</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;   //this method will pause the simulation and stop receiving updates from the SimController. This method will need to interact with the Button class to determine when they have been pressed.</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;}</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;   * private void step(){</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;   //this method will only step through and play one frame of the simulation before pausing it once again. This method will need to interact with the Button class to determine when they have been pressed.</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;}</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;   </div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;   * uploadXML(File file){</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;   //this method will need to interact with the UI Elements and buttons to determine when the Upload XML document has been selected and what filepath has been selected. The buttons will call uploadXML(). This method will then interact with XMLParser and call init with the new file passed in as a parameter}</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;* **SimController**</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;The SimController class will be an abstract class as detailed in “Overview”. </div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;* FireController</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;   FireController class extends SimController and implements its abstract methods as follows:</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;   * getHoodState(hood) returns “fire” if the state of any of the cells in hood are fire and returns “notfire” otherwise.</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;   * newState(cellState, hoodState):</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;       if cellState is “tree”, hoodState is “fire” and Random().nextInt(100) &gt; probCatch:  return “fire”</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;else if cellState is “tree” return “tree”</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;else return “ash”</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;* WaTorController</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;   Extends SimController and implements its abstract methods as follows:</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;   * getHoodState(hood) returns array containing any combination of [“shark”,”fish”, “vacant”] if at least one cell in the neighborhood has the corresponding state.</div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;   * newState(cellState, hoodState):</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;```</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;       if cellState[0] = “Shark”: (cellState = [“Shark”, surviveCount, energyCount]</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;       if hoodState contains “Fish” or “vacant”:</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;           if cellState[1] == reproduceParam:</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;               return [“Shark”, 0, startingEnergy]</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;           else:</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;               return [“vacant”, null, null]</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;       else:</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;           if cellState[2] &gt; 0:</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;               return [“Shark, cellState[1]++, cellState[2]--]</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;           else:</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;               if cellState[1] == reproduceParam:</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                   return [“Shark”, 0, startingEnergy]</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;               else: </div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;                   return [“vacant”, null, null]</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;       if cellState[0] = “Fish”</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;           if hoodState contains “Shark”:</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;               return [“Shark”, surviveCount++, energyCount++]</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;           else if hoodState contains “vacant”:</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;               return [“vacant”, null, null]</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;           else:</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;               return [“Fish”, cellState[1]++, null]</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;       if cellState[0] = “vacant”</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;           if hoodState contains “Shark”:</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;               return  [“Shark”, surviveCount++, enegyCount--]</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;           else if hoodState contains “Fish”:</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;               return [“Fish”, surviveCount++, null]</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;           else:</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;               return [“vacant”, null, null]</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;```</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;* SegController</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;   Extends SimController and implements abstract methods as follows:</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;   * getHoodState(hood) returns happy if (number of adjacent cells that are the same as cellState)/(number of occupied adjacent cells) &gt; happyThreshold</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;   * newState(cellState, hoodState):</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;```</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;       if(hoodState == happy):</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;           return cellState</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;       else:</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;           return vacant</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;```</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;=======</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;* **GameManager**</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;GameManager will contain the following methods</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;   </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;       * init(File file){//this method will initialize the game scene by calling createControllers(); calling createGrid();}</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;   * createControllers(){//this method will interact with the XMLParser class to parse the XML file and set the properties to the revelvant controller}    </div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;   * createGrid(){//this method will create the grid by interacting with the Grid class which holds all specfications for the grid’s attributes and properties}</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;       * updateGrid(){//this method will use setter methods in the Grid class to reset its state based on the results of running the current algorithms. It will need to have access to the SimController and/or the specific controller subclass in order to determine what changes need to be made. </div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;       * private void pause(){//this method will pause the simulation and stop receiving updates from the SimController. This method will need to interact with the Button class to determine when they have been pressed.}</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;       * private void step(){//this method will only step through and play one frame of the simulation before pausing it once again. This method will need to interact with the Button class to determine when they have been pressed.}</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    </div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;       * uploadXML(File file){//this method will need to interact with the UI Elements and buttons to determine when the Upload XML document has been selected and what filepath has been selected. The buttons will call uploadXML(). This method will then interact with XMLParser and call init with the new file passed in as a parameter}</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;* **SimController**</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;       The SimController class will be an abstract class as detailed in “Overview”. </div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;   * FireController</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;FireController class extends SimController and implements its abstract methods as follows:</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;       * getHoodState(hood) returns “fire” if the state of any of the cells in hood are fire and returns “notfire” otherwise.</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;       * newState(cellState, hoodState):</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;if cellState is “tree”, hoodState is “fire” and Random().nextInt(100) &gt; probCatch:  return “fire”</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;else if cellState is “tree” return “tree”</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;else return “ash”</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;   * WaTorController</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;Extends SimController and implements its abstract methods as follows:</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;       * getHoodState(hood) returns array containing any combination of [“shark”,”fish”, “vacant”] if at least one cell in the neighborhood has the corresponding state.</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;       * newState(cellState, hoodState):</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;   </div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;```pseudocode</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;if cellState[0] = “Shark”: (cellState = [“Shark”, surviveCount, energyCount]</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    if hoodState contains “Fish” or “vacant”:</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        if cellState[1] == reproduceParam:</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            return [“Shark”, 0, startingEnergy]</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        else:</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            return [“vacant”, null, null]</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    else:</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        if cellState[2] &gt; 0:</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            return [“Shark, cellState[1]++, cellState[2]--]</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        else:</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            if cellState[1] == reproduceParam:</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                return [“Shark”, 0, startingEnergy]</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            else: </div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                return [“vacant”, null, null]</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;if cellState[0] = “Fish”</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    if hoodState contains “Shark”:</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        return [“Shark”, surviveCount++, energyCount++]</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    else if hoodState contains “vacant”:</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        return [“vacant”, null, null]</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    else:</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        return [“Fish”, cellState[1]++, null]</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;if cellState[0] = “vacant”</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;if hoodState contains “Shark”:</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;return  [“Shark”, surviveCount++, enegyCount--]</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;else if hoodState contains “Fish”:</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    return [“Fish”, surviveCount++, null]</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;else:</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    return [“vacant”, null, null]</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;```</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;SegController</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;Extends SimController and implements abstract methods as follows:</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;   * getHoodState(hood) returns happy if (number of adjacent cells that are the same as cellState)/(number of occupied adjacent cells) &gt; happyThreshold</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;   * newState(cellState, hoodState):</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;if(hoodState == happy):</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    return cellState</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;else:</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    return vacant</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 746ef3b572660248f08e1fd27caefec6afe03ca2</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;* LifeController</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;Extends SimController and implements abstract methods as follows:</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;   * getHoodState(hood) returns lively if  number of nonvacant elements within hood are within threshold range. Else it returns deadly</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;   * newState(cellState, hoodState):</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;```</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;       if(hoodState == lively):</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;           return life</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;       else:</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;           return vacant</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;```</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;Given that there could be updated requirements to this CellSociety project, our number one goal is to make this code extensible so that new changes can be implemented easily. For example, adding a new CA simulation with a new set of rules should be an incredibly easy fix to the program. Likewise, other possible additions like possibly running multiple simulations at once should be very easily implemented. In the design of the SimController class for example, our flexibility can be seen because attention is given to making sure that each individual controller subclass is able to extend the SimController superclass, rather than create separate methods or long &quot;if&quot; trees in order to specify behavior. The FireController, WaTorController, SegController, and LifeController all extend the SimController, which is something that we believe to be good code design.</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;In addition, our design captures some esscences of abstraction and encapsulation. For example, the class that implements the UIElements will likely have no knowledge of any of the any other classes except for event handlers for buttons and any grid paramters passed in. The UIElements class need not know the implementation of any of the other methods and their implementation, just so long as an arbitrary grid is passed with given states for the cells. Likewise, the GameManager and SimController need not have any idea about how the UIElements presents the view to the user. The two controller classes simply modify the current state of the simulation (frame rate, whether paused, cell states, etc.). It does not assume any knowledge of the presentation of this information. Separating the game flow control&#39;s and the user presentation&#39;s implementation details from one another makes it so that the code is very extensible, and changes can be made easily. If the two functions were heavily intertwined, then an additional requirement is much more difficult to implement, since dependencies between the functions need to be continously checked and rechecked.</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;Design Considerations</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;---</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;A number of design considerations were discussed at length. First of all, it was necessary to decide whether the Cell object would contain information regarding its neighbors or not. The advantage to this is that the SimController would not need the getHood() method as this would be intrinsic to the Cell. We decided, however to not have the Cell hold information on its neighboring cells though because, the SimController is dependent on the grid regardless (in order to iterate through every cell) and it would just be extraneous information in the Cell object.</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;Another consideration was whether to parse the XML file in a separate class or within the GameManger class. Putting it in the GameManager class was considered because originally the GameManager had little functionality other than parsing the XML file and calling SimControllers. It made more sense to have GameManager handle all the logic involved with the flow of the game (start, pause, step) and thus it made more sense to parse the XML with a separate XMLParser object.</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;An additional consideration was where to store the algorithm/rules for changing cell states. One option we considered was placing the code for determining a cell’s state directly within the cell class itself. The class could call update() on itself in order to determine its next state and update its state within the same class. However, several issues arose: the cell would need access to adjacent cells, and each cell would need a unique forms of the algorithms. A TreeCell would have to have an algorithm differentiated from a FireCell, and would require specific algorithms to first be hardcoded into each class before the parameters could be passed in. Instead, we decided a separate group of Controller classes could keep access to adjacent cell within the Grid and GameManager classes (reducing the amount that Cell can access) and also by allowing more generalities (and thus extendable functionality) within the Controllers. </div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;Team Responsibilities</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;---</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;=======</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    if(hoodState == lively):</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        return life</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    else:</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        return vacant</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;---</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 9 2015 01:33:45 for cellsociety_team13 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
